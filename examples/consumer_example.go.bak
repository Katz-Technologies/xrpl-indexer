package examples 

import (
	"context"
	// "encoding/hex"
	"encoding/json"
	"strconv"
	// "strings"
	// "sync"

	"github.com/google/uuid"
	"github.com/segmentio/kafka-go"
	"github.com/shopspring/decimal"
	"github.com/xrpscan/platform/config"
	"github.com/xrpscan/platform/connections"
	"github.com/xrpscan/platform/indexer"
	"github.com/xrpscan/platform/logger"
	"github.com/xrpscan/platform/models"
)


func RunBulkConsumer(conn *kafka.Reader, callback func(<-chan kafka.Message)) {
	ctx := context.Background()
	ch := make(chan kafka.Message)
	go callback(ch)

	for {
		m, err := conn.FetchMessage(ctx)
		if err != nil {
			break
		}

		ch <- m

		if err := conn.CommitMessages(ctx, m); err != nil {
			logger.Log.Error().Err(err).Msg("Failed to commit kafka message")
		}
	}
}


func RunConsumers() {
	// Only run the transaction transformer; drop other noisy consumers
	go RunBulkConsumer(connections.KafkaReaderTransaction, func(ch <-chan kafka.Message) {
		ctx := context.Background()
		for {
			m := <-ch
			var tx map[string]interface{}
			if err := json.Unmarshal(m.Value, &tx); err != nil {
				logger.Log.Error().Err(err).Msg("Transaction json.Unmarshal error")
				continue
			}
			// Filter by allowed transaction types at code level
			if tt, ok := tx["TransactionType"].(string); ok {
				if tt != "Payment" {
					// skip unwanted transaction types
					continue
				}
			} else {
				// unknown or missing type; skip
				continue
			}
			modified, err := indexer.ModifyTransaction(tx)
			if err != nil {
				logger.Log.Error().Err(err).Msg("Error fixing transaction object")
				continue
			}
			b, err := json.Marshal(modified)
			if err != nil {
				logger.Log.Error().Err(err).Msg("Transaction json.Marshal error")
				continue
			}

			// Emit CH rows: transactions, assets, money_flows
			var base map[string]interface{} = modified
			hash, _ := base["hash"].(string)
			ledgerIndex, _ := base["ledger_index"].(float64)
			closeTime, _ := base["date"].(float64)
			account, _ := base["Account"].(string)
			destination, _ := base["Destination"].(string)
			result := ""
			if meta, ok := base["meta"].(map[string]interface{}); ok {
				if r, ok := meta["TransactionResult"].(string); ok {
					result = r
				}
			}
			feeDrops := uint64(0)
			if fee, ok := base["Fee"].(float64); ok {
				feeDrops = uint64(fee)
			} else if feeStr, ok := base["Fee"].(string); ok {
				if v, err := strconv.ParseUint(feeStr, 10, 64); err == nil {
					feeDrops = v
				}
			}

			// transactions row (final JSON for CH MV)
			txId := idTx(hash)
			accountId := idAccount(account)
			destId := idAccount(destination)
			const rippleToUnix int64 = 946684800
			closeTimeUnix := int64(closeTime) + rippleToUnix
			txRow := models.CHTransactionRow{
				TxID:          txId,
				Hash:          hash,
				LedgerIndex:   uint32(ledgerIndex),
				CloseTimeUnix: closeTimeUnix,
				TxType:        "Payment",
				AccountID:     accountId,
				DestinationID: destId,
				Result:        result,
				FeeDrops:      feeDrops,
				RawJSON:       string(b),
			}
			if row, err := json.Marshal(txRow); err == nil {
				_ = connections.KafkaWriter.WriteMessages(ctx, kafka.Message{Topic: config.TopicCHTransactions(), Key: []byte(hash), Value: row})
			}

			// ensure XRP asset exists in assets table (emit once per process)
			if _, loaded := emittedAssets.LoadOrStore("XRP", true); !loaded {
				xrpRow := models.CHAssetRow{
					AssetID:   idAssetXRP(),
					AssetType: "XRP",
					Currency:  "XRP",
					IssuerID:  uuid.Nil.String(),
					Symbol:    "XRP",
				}
				if row, err := json.Marshal(xrpRow); err == nil {
					_ = connections.KafkaWriter.WriteMessages(ctx, kafka.Message{Topic: config.TopicCHAssets(), Key: []byte("XRP"), Value: row})
				}
			}

			// accounts rows: emit deduped final JSON rows for CH accounts
			if account != "" {
				aid := idAccount(account)
				if _, loaded := emittedAssets.LoadOrStore("acc:"+account, true); !loaded {
					ar := models.CHAccountRow{AccountID: aid, Address: account}
					if row, err := json.Marshal(ar); err == nil {
						_ = connections.KafkaWriter.WriteMessages(ctx, kafka.Message{Topic: config.TopicCHAccounts(), Key: []byte(account), Value: row})
					}
				}
			}
			if destination != "" {
				did := idAccount(destination)
				if _, loaded := emittedAssets.LoadOrStore("acc:"+destination, true); !loaded {
					dr := models.CHAccountRow{AccountID: did, Address: destination}
					if row, err := json.Marshal(dr); err == nil {
						_ = connections.KafkaWriter.WriteMessages(ctx, kafka.Message{Topic: config.TopicCHAccounts(), Key: []byte(destination), Value: row})
					}
				}
			}

			// assets rows from tx fields (preferred canonical sources)
			issuersByCurrency := make(map[string]string)
			// 1) Amount
			if amt, ok := base["Amount"].(map[string]interface{}); ok {
				cur, _ := amt["currency"].(string)
				cur = normCurrency(cur)
				iss, _ := amt["issuer"].(string)
				if cur != "" && iss != "" {
					issuersByCurrency[cur] = iss
					assetKey := "IOU:" + cur + ":" + iss
					if _, loaded := emittedAssets.LoadOrStore(assetKey, true); !loaded {
						sym := symbolFromCurrencyMap(amt)
						issuerUUID := idAccount(iss)
						assetRow := models.CHAssetRow{AssetID: idAssetIOU(cur, iss), AssetType: "IOU", Currency: cur, IssuerID: issuerUUID, Symbol: sym}
						if row, err := json.Marshal(assetRow); err == nil {
							_ = connections.KafkaWriter.WriteMessages(ctx, kafka.Message{Topic: config.TopicCHAssets(), Key: []byte(assetKey), Value: row})
						}
						if _, loaded2 := emittedAssets.LoadOrStore("acc:"+iss, true); !loaded2 {
							ar := models.CHAccountRow{AccountID: issuerUUID, Address: iss}
							if row2, err2 := json.Marshal(ar); err2 == nil {
								_ = connections.KafkaWriter.WriteMessages(ctx, kafka.Message{Topic: config.TopicCHAccounts(), Key: []byte(iss), Value: row2})
							}
						}
					}
				}
			}
			// 2) SendMax
			if sm, ok := base["SendMax"].(map[string]interface{}); ok {
				cur, _ := sm["currency"].(string)
				cur = normCurrency(cur)
				iss, _ := sm["issuer"].(string)
				if cur != "" && iss != "" {
					if _, ok := issuersByCurrency[cur]; !ok {
						issuersByCurrency[cur] = iss
					}
					assetKey := "IOU:" + cur + ":" + iss
					if _, loaded := emittedAssets.LoadOrStore(assetKey, true); !loaded {
						sym := symbolFromCurrencyMap(sm)
						issuerUUID := idAccount(iss)
						assetRow := models.CHAssetRow{AssetID: idAssetIOU(cur, iss), AssetType: "IOU", Currency: cur, IssuerID: issuerUUID, Symbol: sym}
						if row, err := json.Marshal(assetRow); err == nil {
							_ = connections.KafkaWriter.WriteMessages(ctx, kafka.Message{Topic: config.TopicCHAssets(), Key: []byte(assetKey), Value: row})
						}
						if _, loaded2 := emittedAssets.LoadOrStore("acc:"+iss, true); !loaded2 {
							ar := models.CHAccountRow{AccountID: issuerUUID, Address: iss}
							if row2, err2 := json.Marshal(ar); err2 == nil {
								_ = connections.KafkaWriter.WriteMessages(ctx, kafka.Message{Topic: config.TopicCHAccounts(), Key: []byte(iss), Value: row2})
							}
						}
					}
				}
			}
			// 3) meta.delivered_amount
			if meta, ok := base["meta"].(map[string]interface{}); ok {
				if da, ok := meta["delivered_amount"].(map[string]interface{}); ok {
					cur, _ := da["currency"].(string)
					cur = normCurrency(cur)
					iss, _ := da["issuer"].(string)
					if cur != "" && iss != "" {
						issuersByCurrency[cur] = iss
						assetKey := "IOU:" + cur + ":" + iss
						if _, loaded := emittedAssets.LoadOrStore(assetKey, true); !loaded {
							sym := symbolFromCurrencyMap(da)
							issuerUUID := idAccount(iss)
							assetRow := models.CHAssetRow{AssetID: idAssetIOU(cur, iss), AssetType: "IOU", Currency: cur, IssuerID: issuerUUID, Symbol: sym}
							if row, err := json.Marshal(assetRow); err == nil {
								_ = connections.KafkaWriter.WriteMessages(ctx, kafka.Message{Topic: config.TopicCHAssets(), Key: []byte(assetKey), Value: row})
							}
							if _, loaded2 := emittedAssets.LoadOrStore("acc:"+iss, true); !loaded2 {
								ar := models.CHAccountRow{AccountID: issuerUUID, Address: iss}
								if row2, err2 := json.Marshal(ar); err2 == nil {
									_ = connections.KafkaWriter.WriteMessages(ctx, kafka.Message{Topic: config.TopicCHAccounts(), Key: []byte(iss), Value: row2})
								}
							}
						}
					}
				}
			}

			// money_flow rows derived from AffectedNodes:
			// - transfer: AccountRoot Balance deltas (XRP)
			// - dexOffer/swap: Offer execution inferred from Balance deltas across two assets
			if meta, ok := base["meta"].(map[string]interface{}); ok {
				if nodes, ok := meta["AffectedNodes"].([]interface{}); ok {
					// First pass: collect balance deltas (XRP and IOU) per account+asset
					type assetKey struct{ currency, issuer string }
					type offerPair struct {
						owner string
						gets  assetKey
						pays  assetKey
						quote decimal.Decimal // pays per gets
					}
					offersByOwner := make(map[string][]offerPair)
					balances := make(map[string]map[assetKey]decimal.Decimal)
					for _, n := range nodes {
						node, _ := n.(map[string]interface{})
						var fields map[string]interface{}
						var obj map[string]interface{}
						if created, ok := node["CreatedNode"].(map[string]interface{}); ok {
							obj = created
							fields, _ = created["NewFields"].(map[string]interface{})
						} else if modified, ok := node["ModifiedNode"].(map[string]interface{}); ok {
							obj = modified
							fields, _ = modified["FinalFields"].(map[string]interface{})
						} else if deleted, ok := node["DeletedNode"].(map[string]interface{}); ok {
							obj = deleted
							fields, _ = deleted["FinalFields"].(map[string]interface{})
						}
						if fields == nil {
							continue
						}
						ledgerType, _ := obj["LedgerEntryType"].(string)
						switch ledgerType {
						case "AccountRoot":
							addr, _ := fields["Account"].(string)
							if addr == "" {
								continue
							}
							var prevBalance, finalBalance int64
							if modified, ok := node["ModifiedNode"].(map[string]interface{}); ok {
								if pf, ok := modified["PreviousFields"].(map[string]interface{}); ok {
									if pb, ok := pf["Balance"].(string); ok {
										if v, err := strconv.ParseInt(pb, 10, 64); err == nil {
											prevBalance = v
										}
									}
								}
								if ff, ok := modified["FinalFields"].(map[string]interface{}); ok {
									if fb, ok := ff["Balance"].(string); ok {
										if v, err := strconv.ParseInt(fb, 10, 64); err == nil {
											finalBalance = v
										}
									}
								}
							}
							if prevBalance != 0 || finalBalance != 0 {
								delta := decimal.NewFromInt(finalBalance - prevBalance).Div(decimal.NewFromInt(int64(models.DROPS_IN_XRP)))
								if !delta.IsZero() {
									if _, ok := balances[addr]; !ok {
										balances[addr] = make(map[assetKey]decimal.Decimal)
									}
									k := assetKey{currency: "XRP", issuer: ""}
									balances[addr][k] = balances[addr][k].Add(delta)
								}
							}
						case "RippleState":
							// IOU trustline balance delta
							// Extract account, currency, issuer and delta from PreviousFields/FinalFields.Balance.value
							high, _ := fields["HighLimit"].(map[string]interface{})
							low, _ := fields["LowLimit"].(map[string]interface{})
							bal, _ := fields["Balance"].(map[string]interface{})
							currency, _ := bal["currency"].(string)
							currency = normCurrency(currency)
							issuerHigh, _ := high["issuer"].(string)
							issuerLow, _ := low["issuer"].(string)
							// Determine which side increased/decreased by comparing PreviousFields/FinalFields
							var prevV, finalV decimal.Decimal
							if modified, ok := node["ModifiedNode"].(map[string]interface{}); ok {
								if pf, ok := modified["PreviousFields"].(map[string]interface{}); ok {
									if pb, ok := pf["Balance"].(map[string]interface{}); ok {
										if vs, ok := pb["value"].(string); ok {
											prevV, _ = decimal.NewFromString(vs)
										}
									}
								}
								if ff, ok := modified["FinalFields"].(map[string]interface{}); ok {
									if fb, ok := ff["Balance"].(map[string]interface{}); ok {
										if vs, ok := fb["value"].(string); ok {
											finalV, _ = decimal.NewFromString(vs)
										}
									}
								}
							}
							if prevV.Equal(finalV) {
								continue
							}
							// RippleState.balance is from low->high perspective
							// delta > 0 => transfer from high to low (low receives)
							abs := finalV.Sub(prevV)
							recv := issuerLow
							send := issuerHigh
							if abs.IsNegative() {
								// delta < 0 => transfer low -> high
								abs = abs.Neg()
								recv = issuerHigh
								send = issuerLow
							}
							issuer := issuersByCurrency[currency]
							if _, ok := balances[recv]; !ok {
								balances[recv] = make(map[assetKey]decimal.Decimal)
							}
							if _, ok := balances[send]; !ok {
								balances[send] = make(map[assetKey]decimal.Decimal)
							}
							k := assetKey{currency: currency, issuer: issuer}
							balances[recv][k] = balances[recv][k].Add(abs) // receiver +abs
							balances[send][k] = balances[send][k].Sub(abs) // sender -abs

							// Do not emit assets from RippleState to avoid issuer ambiguity
						case "Offer":
							// Collect offer asset pairs and approximate execution quote from deltas
							owner, _ := fields["Account"].(string)
							if owner == "" {
								break
							}
							// Parse helper
							parseAmount := func(v interface{}) (assetKey, decimal.Decimal) {
								if m, ok := v.(map[string]interface{}); ok {
									cur, _ := m["currency"].(string)
									cur = normCurrency(cur)
									iss, _ := m["issuer"].(string)
									vs, _ := m["value"].(string)
									val, _ := decimal.NewFromString(vs)
									return assetKey{currency: cur, issuer: iss}, val
								}
								if s, ok := v.(string); ok {
									// XRP in drops
									iv, _ := decimal.NewFromString(s)
									x := iv.Div(decimal.NewFromInt(int64(models.DROPS_IN_XRP)))
									return assetKey{currency: "XRP", issuer: ""}, x
								}
								return assetKey{}, decimal.Zero
							}
							getPrevFinal := func(obj map[string]interface{}) (prevGets, finGets assetKey, prevG, finG decimal.Decimal, prevPays, finPays assetKey, prevP, finP decimal.Decimal) {
								var pf, ff map[string]interface{}
								if modified, ok := obj["ModifiedNode"].(map[string]interface{}); ok {
									pf, _ = modified["PreviousFields"].(map[string]interface{})
									ff, _ = modified["FinalFields"].(map[string]interface{})
								} else if deleted, ok := obj["DeletedNode"].(map[string]interface{}); ok {
									pf, _ = deleted["PreviousFields"].(map[string]interface{})
									ff, _ = deleted["FinalFields"].(map[string]interface{})
								} else if created, ok := obj["CreatedNode"].(map[string]interface{}); ok {
									ff, _ = created["NewFields"].(map[string]interface{})
								}
								if pf != nil {
									pgAK, pg := parseAmount(pf["TakerGets"]) // previous gets
									ppAK, pp := parseAmount(pf["TakerPays"]) // previous pays
									prevGets, prevG = pgAK, pg
									prevPays, prevP = ppAK, pp
								}
								if ff != nil {
									fgAK, fg := parseAmount(ff["TakerGets"]) // final gets
									fpAK, fp := parseAmount(ff["TakerPays"]) // final pays
									finGets, finG = fgAK, fg
									finPays, finP = fpAK, fp
								}
								return
							}
							prevGetsAK, finGetsAK, prevGetsAmt, finGetsAmt, prevPaysAK, finPaysAK, prevPaysAmt, finPaysAmt := getPrevFinal(node)
							// Prefer asset keys from FinalFields when available, else PreviousFields
							getsAK := finGetsAK
							paysAK := finPaysAK
							if getsAK.currency == "" {
								getsAK = prevGetsAK
							}
							if paysAK.currency == "" {
								paysAK = prevPaysAK
							}
							// Compute executed amounts (previous - final)
							execGets := prevGetsAmt.Sub(finGetsAmt)
							execPays := prevPaysAmt.Sub(finPaysAmt)
							if execGets.IsNegative() {
								execGets = execGets.Neg()
							}
							if execPays.IsNegative() {
								execPays = execPays.Neg()
							}
							quote := decimal.Zero
							if !execGets.IsZero() {
								quote = execPays.Div(execGets)
							}
							// Record offer pair only if we have both sides
							if getsAK.currency != "" && (paysAK.currency != "" || (paysAK.currency == "XRP" && paysAK.issuer == "")) {
								offersByOwner[owner] = append(offersByOwner[owner], offerPair{owner: owner, gets: getsAK, pays: paysAK, quote: quote})
							}
						}
					}

					// Build edges by matching positive and negative deltas per asset
					epsilon := decimal.New(1, -12) // 1e-12 to drop dust
					type edge struct {
						from, to string
						asset    assetKey
						amount   decimal.Decimal
					}
					edges := make([]edge, 0)
					for ak := range func(m map[string]map[assetKey]decimal.Decimal) map[assetKey]struct{} {
						u := make(map[assetKey]struct{})
						for _, mm := range m {
							for k := range mm {
								u[k] = struct{}{}
							}
						}
						return u
					}(balances) {
						// collect sources and sinks for this asset
						type pair struct {
							addr string
							amt  decimal.Decimal
						}
						sources := make([]pair, 0)
						sinks := make([]pair, 0)
						for addr, mm := range balances {
							amt := mm[ak]
							if amt.IsZero() {
								continue
							}
							if amt.IsNegative() {
								sources = append(sources, pair{addr, amt.Neg()})
							} else {
								sinks = append(sinks, pair{addr, amt})
							}
						}
						// greedy match
						i, j := 0, 0
						for i < len(sources) && j < len(sinks) {
							s := sources[i]
							t := sinks[j]
							take := decimal.Min(s.amt, t.amt)
							if take.IsZero() || take.LessThan(epsilon) {
								break
							}
							edges = append(edges, edge{from: s.addr, to: t.addr, asset: ak, amount: take})
							s.amt = s.amt.Sub(take)
							t.amt = t.amt.Sub(take)
							if s.amt.IsZero() {
								i++
							} else {
								sources[i] = s
							}
							if t.amt.IsZero() {
								j++
							} else {
								sinks[j] = t
							}
						}
					}

					// Determine tx-level from/to assets for initiator using Payment fields
					var txFromAK, txToAK assetKey
					hasTxFrom, hasTxTo := false, false
					parseAK := func(v interface{}) (assetKey, bool) {
						m, ok := v.(map[string]interface{})
						if !ok {
							return assetKey{}, false
						}
						cur, _ := m["currency"].(string)
						cur = normCurrency(cur)
						iss, _ := m["issuer"].(string)
						if cur == "" {
							return assetKey{}, false
						}
						return assetKey{currency: cur, issuer: iss}, true
					}
					if sm, ok := base["SendMax"].(map[string]interface{}); ok {
						txFromAK, hasTxFrom = parseAK(sm)
					} else if _, ok := base["SendMax"].(string); ok {
						// SendMax as string (XRP in drops)
						txFromAK = assetKey{currency: "XRP", issuer: ""}
						hasTxFrom = true
					}
					if da, ok := meta["delivered_amount"].(map[string]interface{}); ok {
						txToAK, hasTxTo = parseAK(da)
					} else if amt, ok := base["Amount"].(map[string]interface{}); ok {
						txToAK, hasTxTo = parseAK(amt)
					}
					txAssetsDiffer := hasTxFrom && hasTxTo && (txFromAK != txToAK)

					// Initiator account for this transaction
					initiator := account

					// Compute initiator totals for quote derivation
					spentBy := make(map[assetKey]decimal.Decimal)
					recvBy := make(map[assetKey]decimal.Decimal)
					for _, e := range edges {
						if e.from == initiator {
							spentBy[e.asset] = spentBy[e.asset].Add(e.amount)
						}
						if e.to == initiator {
							recvBy[e.asset] = recvBy[e.asset].Add(e.amount)
						}
					}
					initiatorQuote := decimal.Zero
					if txAssetsDiffer {
						spent := spentBy[txFromAK]
						recvd := recvBy[txToAK]
						if !spent.IsZero() && !recvd.IsZero() {
							initiatorQuote = recvd.Div(spent)
						}
					}

					// Heuristics to classify kind per edge
					// Determine if initiator participates in multi-asset (swap)
					seenAssetsForInitiator := 0
					uniq := make(map[assetKey]struct{})
					for _, e := range edges {
						if e.from == initiator || e.to == initiator {
							if _, ok := uniq[e.asset]; !ok {
								uniq[e.asset] = struct{}{}
								seenAssetsForInitiator++
							}
						}
					}

					// Index edges by directed pair to allow cross-asset pairing
					edgesByPair := make(map[string][]edge)
					pairKey := func(a, b string) string { return a + "|" + b }
					for _, e := range edges {
						k := pairKey(e.from, e.to)
						edgesByPair[k] = append(edgesByPair[k], e)
					}

					for _, e := range edges {
						kind := "transfer"
						// compute IDs
						accFrom := idAccount(e.from)
						accTo := idAccount(e.to)
						var fromAssetId string
						if e.asset.currency == "XRP" {
							fromAssetId = idAssetXRP()
						} else {
							fromAssetId = idAssetIOU(normCurrency(e.asset.currency), e.asset.issuer)
						}
						// magnitude for current edge
						amtAbs := e.amount
						if amtAbs.IsNegative() {
							amtAbs = amtAbs.Neg()
						}
						if amtAbs.LessThan(epsilon) {
							continue
						}
						// find reverse edge to determine counter-asset and amount
						revList := edgesByPair[pairKey(e.to, e.from)]
						var toAmt decimal.Decimal
						var toAssetId string
						for _, re := range revList {
							if re.asset.currency != e.asset.currency || re.asset.issuer != e.asset.issuer {
								toAmt = re.amount
								if toAmt.IsNegative() {
									toAmt = toAmt.Neg()
								}
								if re.asset.currency == "XRP" {
									toAssetId = idAssetXRP()
								} else {
									toAssetId = idAssetIOU(normCurrency(re.asset.currency), re.asset.issuer)
								}
								break
							}
						}
						if toAssetId == "" {
							if len(revList) > 0 {
								re := revList[0]
								toAmt = re.amount
								if toAmt.IsNegative() {
									toAmt = toAmt.Neg()
								}
								if re.asset.currency == "XRP" {
									toAssetId = idAssetXRP()
								} else {
									toAssetId = idAssetIOU(normCurrency(re.asset.currency), re.asset.issuer)
								}
							}
						}
						// Offer-based fallback: if still same-asset or empty, try to infer via offers
						if toAssetId == fromAssetId || toAssetId == "" {
							matchAsset := func(a1, a2 assetKey) bool {
								if a1.currency != a2.currency {
									return false
								}
								if a1.issuer != "" && a2.issuer != "" && a1.issuer != a2.issuer {
									return false
								}
								return true
							}
							useOffer := func(owner string) bool {
								list := offersByOwner[owner]
								for _, op := range list {
									if matchAsset(e.asset, op.gets) {
										// counter is pays
										if op.pays.currency == "XRP" {
											toAssetId = idAssetXRP()
										} else {
											toAssetId = idAssetIOU(normCurrency(op.pays.currency), op.pays.issuer)
										}
										if !op.quote.IsZero() {
											toAmt = amtAbs.Mul(op.quote)
										} else if !initiatorQuote.IsZero() && (owner == initiator || e.from == initiator || e.to == initiator) {
											toAmt = amtAbs.Mul(initiatorQuote)
										}
										return true
									}
									if matchAsset(e.asset, op.pays) {
										// counter is gets
										if op.gets.currency == "XRP" {
											toAssetId = idAssetXRP()
										} else {
											toAssetId = idAssetIOU(normCurrency(op.gets.currency), op.gets.issuer)
										}
										if !op.quote.IsZero() {
											// invert
											toAmt = amtAbs.Div(op.quote)
										} else if !initiatorQuote.IsZero() && (owner == initiator || e.from == initiator || e.to == initiator) {
											toAmt = amtAbs.Div(initiatorQuote)
										}
										return true
									}
								}
								return false
							}
							if !useOffer(e.from) {
								_ = useOffer(e.to)
							}
						}

						// If still unresolved, default to same-asset transfer
						if toAssetId == "" {
							toAssetId = fromAssetId
							if toAmt.IsZero() {
								toAmt = amtAbs
							}
						}

						// Classify kind after determining assets
						if (e.from == initiator || e.to == initiator) && seenAssetsForInitiator >= 2 {
							kind = "swap"
						} else if toAssetId != fromAssetId {
							kind = "dexOffer"
						} else {
							kind = "transfer"
						}
						// Fallback improvement: if initiator is involved and tx indicates cross-asset,
						// but we couldn't find a proper reverse edge (or we paired same-asset),
						// use tx-level from/to assets and initiatorQuote to derive counter amount.
						if (toAssetId == fromAssetId || toAssetId == "") && txAssetsDiffer && (e.from == initiator || e.to == initiator) && hasTxTo {
							// set toAssetId from txToAK
							if txToAK.currency == "XRP" {
								toAssetId = idAssetXRP()
							} else {
								toAssetId = idAssetIOU(normCurrency(txToAK.currency), txToAK.issuer)
							}
							if !initiatorQuote.IsZero() {
								toAmt = amtAbs.Mul(initiatorQuote)
							} else if toAmt.IsZero() {
								toAmt = amtAbs
							}
						}
						quote := decimal.Zero
						if !amtAbs.IsZero() {
							quote = toAmt.Div(amtAbs)
						}
						// sender (debit): from -> to
						mfSend := models.CHMoneyFlowRow{
							TxID:        txId,
							FromID:      accFrom,
							ToID:        accTo,
							FromAssetID: fromAssetId,
							ToAssetID:   toAssetId,
							FromAmount:  amtAbs.Neg().String(),
							ToAmount:    toAmt.String(),
							Quote:       quote.String(),
							Kind:        kind,
						}
						if row, err := json.Marshal(mfSend); err == nil {
							_ = connections.KafkaWriter.WriteMessages(ctx, kafka.Message{Topic: config.TopicCHMoneyFlows(), Key: []byte(hash), Value: row})
						}
						// receiver (credit): flip direction and swap asset/amounts
						quoteInv := decimal.Zero
						if !toAmt.IsZero() {
							quoteInv = amtAbs.Div(toAmt)
						}
						mfRecv := models.CHMoneyFlowRow{
							TxID:        txId,
							FromID:      accTo,
							ToID:        accFrom,
							FromAssetID: toAssetId,
							ToAssetID:   fromAssetId,
							FromAmount:  toAmt.Neg().String(),
							ToAmount:    amtAbs.String(),
							Quote:       quoteInv.String(),
							Kind:        kind,
						}
						if row, err := json.Marshal(mfRecv); err == nil {
							_ = connections.KafkaWriter.WriteMessages(ctx, kafka.Message{Topic: config.TopicCHMoneyFlows(), Key: []byte(hash), Value: row})
						}
					}
				}
			}
		}
	})
}